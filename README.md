##### 单点登录
###### 什么是单点登录：

单点登录英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。

###### 单点登陆解决的问题：
在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于运营人员来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。
###### 单点登陆系统图示：
![](https://github.com/yujiaweitobebetter/internship_yujiawei/blob/master/some%20image/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.png)
如图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（SSO）的定义。
###### 登陆认证机制：
![](https://github.com/yujiaweitobebetter/internship_yujiawei/blob/master/some%20image/%E7%99%BB%E9%99%86%E6%9C%BA%E5%88%B6.png)
如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。
登陆
相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明
下面对上图简要描述
![](https://github.com/yujiaweitobebetter/internship_yujiawei/blob/master/some%20image/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E2%80%94%E2%80%94%E7%99%BB%E9%99%86.png)
1. 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
2. sso认证中心发现用户未登录，将用户引导至登录页面
3. 用户输入用户名密码提交登录申请
4. sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌
5. sso认证中心带着令牌跳转会最初的请求地址（系统1）
6. 系统1拿到令牌，去sso认证中心校验令牌是否有效
7. sso认证中心校验令牌，返回有效，注册系统1
8. 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源
9. 用户访问系统2的受保护资源
10. 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
11. sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌
12. 系统2拿到令牌，去sso认证中心校验令牌是否有效
13. sso认证中心校验令牌，返回有效，注册系统2
14. 系统2使用该令牌创建与用户的局部会话，返回受保护资源

用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系
- 局部会话存在，全局会话一定存在
- 全局会话存在，局部会话不一定存在
- 全局会话销毁，局部会话必须销毁








##### 微服务：

###### 什么是微服务： 
微服务是一种架构风格，将一个大项目拆分为多个小的、独立的微服务（功能单元）。
###### 传统单体大项目的缺点：
- 系统较大、较复杂，开发难度大
- 部署速度慢
- 难以升级、维护

###### 微服务的特点：
- 小：微服务是体积较小的功能单元，将一个大项目拆分为多个微服务。
- 独：服务都是独立的，运行在单独的JVM进程中，需要单独部署、维护，服务可以使用不同的编程语言来写，可以使用不同的数据库。每个服务往往都要做集群（节点数视该服务的访问量而定）。
- 轻：服务之间的通信机制是轻量级的
- 松：服务之间是松耦合的

###### 微服务的优点：
- 易于开发、维护，扩展性好
- 启动快，修改局部无需重新部署整个项目
- 技术栈不受限制
- 使用微服务时，可以针对性地设置集群大小，比如电商网站，商品、订单模块负载大，集群节点多些；积分模块负载小，集群节点少些。

###### 微服务的缺点：
- 要部署、维护多个服务（服务治理），运维难度加大。
- 单体应用使不使用分布式都行，微服务一般都要使用分布式，对开发人员的技术要求较高
- 调整接口成本高，需要同时修改调用它的其它微服务。
- 代码重复多。单体应用把要重复调用代码封装为工具类，项目中直接调用即可；每个微服务都是独立的，不能调用其它微服务中的类，需要把要用的类copy到要本服务中。
- 事务难度增加，要使用分布式事务。比如购买商品获赠积分，订单服务创建订单+积分服务增加积分，这是一个事务，但不在同一个应用中，使用事务难度增大。

##### 容器
###### 什么是容器：
容器就是将软件打包成标准化单元，以用于开发、交付和部署，是一种虚拟化解决方案，相对于传统虚拟机不同。传统的虚拟机是用中间层，将一台或多台独立的机器虚拟运行在硬件之上。而容器则是直接运行操作系统之上的用户空间，因此容器虚拟又被称为操作系统虚拟化。由于容器依赖于操作系统的特性，因此容器只能运行相同或相似内核的操作系统。
##### 容器和虚拟机的对比：

- 容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。
- 虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。
- 容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动 。
- 容器和虚拟机的对比如图所示
![](https://github.com/yujiaweitobebetter/internship_yujiawei/blob/master/some%20image/vm%E5%92%8C%E5%AE%B9%E5%99%A8.png)

##### Docker
###### 什么是Docker:
Docker是一套完整的容器管理系统，Docker提供了一组命令，让用户更加方便直接地使用容器技术，而不需要过多关心底层内核技术。Docker 是一个开源的应用容器引擎，基于Go 语言并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。
###### Docker的三个基本概念:
- 镜像（Image）
- 容器（Container）
- 仓库（Repository）

 - 镜像：
镜像是容器构建的基石，是基于联合文件系统的一种层式结构由一系列指令构建，是一种轻量级、可执行的独立软件包，用于打包软件运行环境和基于运行环境开发的软件（代码、运行时、库、环境变量和配置文件）。Docker镜像是一个只读模板，它包含创建 Docker容器的说明。它和系统安装光盘有点像，使用系统安装光盘可以安装系统，同理，使用Docker镜像可以运行 Docker镜像中的程序。
 - 容器（container）：
Docker利用容器（container）独立运行的一个或者一组应用。容器是利用镜像创建的运行实例。可以把容器看做是一个简易版的Linux环境 (包括root用户名权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序。
 - 仓库（repository）:
 是集中存放镜像文件的场所 。最大的公开仓库是docker hub存放了数量庞大的镜像供用户下载。
 
###### 总结：
- Docker本身是一个容器运行载体或者称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就叫image镜像文件。 只有通过这个镜像文件才能生成docker容器。image文件可以看做是容器的模板。 Docker根据image文件生成容器的实例。 同一个image文件，可以生成多个同时运行的容器实例。
- image文件生成的容器实例，本身也是一个文件，称为镜像文件；
- 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器；
- 至于仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来就可以了。
- 一句话：去仓库将镜像拉取到本地，然后使用一条命令将镜像运行起来，变成容器。

###### Docker架构图：
![](https://github.com/yujiaweitobebetter/internship_yujiawei/blob/master/some%20image/Docker%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

###### Docker优点:
 - 相比于传统的虚拟化技术,容器更加简洁高效;
 - 传统虚拟机需要给每个VM安装操作系统;
 - 容器使用的共享公共库和程序;
 
###### Docker的用途
1. 提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。
2. 提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。
3. 组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构

##### 微服务的容器化
站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器等等。Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。这正是微服务（microservices）的思想：软件把任务外包出去，让各种外部服务完成这些任务，软件本身只是底层服务的调度中心和组装层。微服务很适合用 Docker 容器实现，每个容器承载一个服务。一台计算机同时运行多个容器，从而就能很轻松地模拟出复杂的微服务架构。

###### 微服务容器化的原因及优势：
1、资源成本：轻量级容器资源利用率更高，容器成本相对较低
2、管理成本：m个微服务n个实例，可能需要m * n个虚机，虚机服务器管理成本较高（当然一个虚机可能部署多个实例），而容器直接在物理机上运行，可直接通过云管平台管理，管理复杂度较低。微服务化程度越高，容器技术的管理成本越低。
3、应用部署成本：容器一般通过镜像（OS+发布包）进行部署，一键发布（集成云管或者Jenkins），部署快效率高;而虚机通过在OS上部署发布包进行部署，虽然可以通过自动化（Ansible）等手段发布，但总体上没有容器技术高效便捷。
4、扩缩容效率：在服务器资源充足的情况下，容器技术可分钟级扩容，而虚机则由于技术、流程问题可能需要小时级甚至几天时间，所以容器技术更加快速便捷。



